# python-differentiation

---

## 최적화와 미분
최적화 분야에서는 미분이 필수적으로 사용된다.<br/>
최솟값을 구함으로써 최적화를 위한 비용을 줄일 수 있는 경우가 많기 때문이다.

최적화의 대표적인 예로 경사하강법이 있는데 미분을 어떻게 사용하는지 잘 보여주는 예시이다.<br/>
경사하강법은 신경망의 (정답값-예측값)을 나타내는 손실함수의 최소값을 찾는 것을 목적으로 한다.<br/>
손실함수의 최소가 갖는 의의는 (정답값-예측값)이 최소일 때, 즉, 예측이 가장 정확할 때를 의미한다.<br/>
그렇게 손실함수의 최소를 찾는 것이다.<br/>
<br/>
그렇다면 손실함수의 최소를 어떻게 찾을까? <br/>
우리는 이미 수학2, 미적분 시간에 함수의 최소를 구하는 방법을 배웠다. <br/>
기울기가 0이면서 좌, 우의 y값보다 작은 지점이 최소가 될것이다. <br/>
이 원리는 경사하강법에도 똑같이 적용된다. <br/>
<br/>
근데 한가지 문제가 있다. <br/>
우리는 기울기가 0인 지점을 구할 때 인수분해하거나 식을 조작하는 방법으로 기울기가 0이 되는 지점을 찾았지만, 컴퓨터에 같은 방식을 적용하기에는 구현해야할 경우가 너무 많기에 그렇게 할 수 없다는 것이다. <br/>
(y’ = x^2 + 2x + 1)를 완전제곱식으로 고쳐서 바로 y’ 이 0되는 x를 구할 수 있는 건 계산에 익숙해진 인간만 가능하다. <br/>

## 컴퓨터로 미분을 하는 방법
그렇기에 컴퓨터로 미분을 할 때에는 다른 방법을 사용해야한다.<br/>
<br/>
크게 두 가지 예시가 있는데,<br/>
첫 번째가 우리가 이미 고등학교 수업시간에 도함수의 정의에서 배운 **'수치 미분(numerical differentiation)'** 을 프로그램으로 구현하는 것이고,<br/>
두 번째는 **‘자동 미분(automatic differentiation)’** 이다.<br/>
<br/>
수치 미분을 프로그램으로 구현하는 건 매우 간단하다.
`{f(x+h) - f(x-h)} / 2h}` 에서 h를 0.001과 같은 매우 작은 값으로 두고 계산하면 lim 기호 없이도 미분을 근사할 수 있다.<br/>
<br/>
그런데 이러한 수치 미분 구현에는 심각한 문제점이 있다.<br/>
h를 너무 크게 두면 값이 부정확할 수 있고, h를 너무 작게두면 부동소수점 특성상 오차가 발생한다.<br/>
또한, 함수의 변수 개수, 즉 차원이 늘어날 수록 계산 복잡도가 기하급수적으로 늘어난다.<br/>
<br/>
이러한 문제들을 감안하여 해결한 것이 자동 미분이다.<br/>
자동 미분을 요약하자면 함수의 연산을 가장 기본적인 형태로 바꾸어 합성함수 형태로 만들어 연쇄 법칙(chain rule)를 활용해서 미분하는 것이다.<br/>

## 자동 미분의 예시
이해하기 어려울 수 있으니 예시를 설명하겠다.<br/>
<br/>
예를 들어 함수 `f(x) = x^2 + x` 가 있다고 해보자. .<br/>
이 함수를 다음과 같이 표현할 수 있다. `f(x) = add(x^2, x) = add(mul(x,x),x)`

<img width="510" alt="A" src="https://github.com/user-attachments/assets/1a00de12-f9a6-46a0-8ebe-a1850c7b872a" />
<br/>
위와 같이 함수의 연산관계를 나타낸 그래프를 활용해서 자동미분에 대한 직관적 이해를 쉽게할 수 있다.<br/>
<br/>
자동 미분에는 forward와 backward가 있지만, 이번에는 backward에 대해서 설명하려고 한다.<br/>
<br/>
기본적인 아이디어는 함수의 최종 형태 E에서 그래프 끝에 있는 A, B, D까지 체인룰로 엮도록 미분하는 것이다.<br/>
<br/>
x에 2가 들어간다고 생각하고, E부터 시작해보겠다.<br/>


1. 가장 먼저 E를 E에 대해서 미분하면 `dE/dE = 1`이다.

2. 그 다음 C와 D에 대해 미분한다.
  - `dE/dC = (dE/dE)(dE/dC) = 1×1 = 1`
  - `dE/dD = (dE/dE)(dE/dD) = 1×1 = 1`

3. 이어서 C의 이전 노드 A와 B에 대해 미분한다.
  - `C = A * B` 이므로 `dC/dA = B = 2, dC/dB = A = 2`
  - `dE/dA = (dE/dC)(dC/dA) = 1×2 = 2`
  - `dE/dB = (dE/dC)(dC/dB) = 1×2 = 2`

4. 모든 미분을 다 완료했으므로 ...
  - `(dE/dA) + (dE/dB) + (dE/dD) = 2 + 2 + 1 = 5`이다.

5. `f′(x) = 2x + 1`에 따라 `f′(2) = 5`이므로 결과가 동일함을 확인할 수 있다.

<br/>
이 예시에서는 더하기와 곱하기 정도만 사용되었지만, 실제 문제에서는 exp, log의 미분부터 ReLU나 Sigmoid 같은 복잡한 함수의 미분도 할 수 있어야 한다.<br/>
<br/>
자동 미분은 이러한 연산을 미리 구현해두고 필요할 때 가져다 쓰는 식으로 동작한다.
